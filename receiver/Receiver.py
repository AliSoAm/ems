import base64
import json
import logging
import subprocess
import traceback
from core.Managers import ConfigurationManager
from git import Repo, GitCommandError
import os

__author__ = 'lto,ogo'

import stomp

log = logging.getLogger(__name__)
#the environmental variable SCRIPTS_PATH is set everytime the script-path was contained in the json message, you can use after you cloned or saved the script
SCRIPTS_PATH = "/opt/openbaton/scripts"


class EMSReceiver(stomp.ConnectionListener):
    def __init__(self, conn, hostname="generic"):
        self.conn = conn
        self.hostname = hostname
        self.configuration_manager = ConfigurationManager()

    def on_error(self, headers, message):
        log.info('received an error %s' % message)

    def on_message(self, headers, message):

        log.info('received a message: %s' % message)
        try:
            dict_msg = json.loads(message)

            action = dict_msg.get('action')

            payload = dict_msg.get('payload')
        except ValueError: #this section deals with the case when the message is not a json message and as a result cannot be processed. Considering that the messages are generated by the NFVO this is not supposed to happen
            print "Not a json object"
            action = None
            out = None
            err = "Not a json message"
            status = "1"
        if action == 'SAVE_SCRIPTS':
            path = dict_msg.get('script-path')
            try:
                script = base64.b64decode(payload)

                if path == None:
                    print "No path provided, saving into default directory"
                    path = SCRIPTS_PATH
                if not os.path.exists(path):
                    os.makedirs(path)
                name = dict_msg.get('name')

                if path[-1] == "/":
                    path_name = path + "/" + name
                else:
                    path_name = path + name

                os.environ['SCRIPTS_PATH'] = path
                f = open(path_name, "w")
                f.write(script)
                log.info("Written %s into %s" % (script, path_name))
                out = str(os.listdir(path))
                err = ""
                status = 0
            except TypeError: #catches typeerror in case of the message not being properly encoded
                print "Incorrect script encoding"
                action = None
                out = None
                err = "Incorrect script encoding"
                status = "1"

        if action == 'CLONE_SCRIPTS':
            path = dict_msg.get('script-path')
            if path == None:
                path = SCRIPTS_PATH
            url = payload
            os.environ['SCRIPTS_PATH'] = path
            log.debug("Cloning into: %s" % url)
            try:
                Repo.clone_from(url, path)
            except GitCommandError as e:
                err = traceback.format_exc()
                status = e.status
                out = None
            else:
                out = str(os.listdir(path))
                err = ""
                status = 0
        elif action == "EXECUTE":

            if payload[-1] == "/":
                payload = SCRIPTS_PATH + payload
            else:
                payload = SCRIPTS_PATH + "/" + payload
            env = dict_msg.get('env')
            log.debug("Executing: %s with env %s" % (payload, env))
            if env is None or len(env) == 0:
                env = None
            else:
                env.update(os.environ)

            proc = subprocess.Popen(["/bin/bash"] + payload.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env)
            status = proc.wait()

            err, out = proc.communicate()
            log.debug("Executed: ERR: %s OUT: %s", err,out )


        elif action == "SCRIPTS_UPDATE":
            url = payload
            try:
                Repo.pull(url, "/opt/openbaton/scripts/")
            except GitCommandError as e:
                err = traceback.format_exc()
                status = e.status
                out = None
            else:
                out = str(os.listdir(SCRIPTS_PATH))
                err = ""
                status = 0

        if out is None:
            out = ""
        if err is None:
            err = ""

        resp = {
            'output': out,
            'err': err,
            'status': status
        }
        json_str = json.dumps(resp)
        log.info("answer is: " + json_str)

        self.conn.send(body=json_str, destination='/queue/%s-vnfm-actions' % self.hostname)
